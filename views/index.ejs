<!DOCTYPE html>
<meta charset="utf-8">
<head>
	<title>Spark Coin Client - <%-clientName%></title>
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="stylesheet" href="/node_modules/jquery-ui/dist/themes/dark-hive/jquery-ui.css">
	<style>
		body { margin: 0; padding-bottom: 3rem; font:12pt Consolas; color:#FFFFFF; background:#000000 repeat url("https://spark-coin.com/public/4452639598_c7d981777f_o.jpg");}
		#campaignName { text-align:center;}
		#timeline { display:flex; position:relative; align-items:center; top:0; margin:0.5em 2em; }
		#timelineBefore { width:33%; height:0.1em; background:#0000FF; }
		#timelineDuring { width:34%; border-radius: 0.5em/50%; height:1em; min-width:1em; background:#0000FF; }
		#timelineAfter { width:33%; height:0.1em;  background:#0000FF; }
		#timelineNow { position:absolute; width:0.5em; height:0.5em; border-radius: 50%; background:#FF0000; }
		#campaignMessage { }

		#preamble { color:#444; font-style:italic; list-style-type: none; margin: 0; padding: 0; }      			
		#activity { height: 15vh; width:95%; position: fixed; bottom: 0; overflow-y: scroll; white-space:nowrap; margin: auto 15px; font: 12pt system-ui; background: #00000044; border: 1px solid black; backdrop-filter: blur(10px); border-radius: 25px; filter: drop-shadow(10px 10px 6px black);}
		#messages { list-style-type: none; margin: 0; padding: 0; }
		#messages > li { padding: 0rem; }

		#form { display: none; background: rgba(128, 128, 128, 0.5); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; height: 2rem; box-sizing: border-box; backdrop-filter: blur(10px); }
		#input { border: none; padding: 0; flex-grow: 1; margin: 0.25rem; }
		#input:focus { outline: none; }
		#form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }
		.t{ color:#888888; } 
		
		#tooltip { position: fixed; white-space:nowrap; opacity: 0; background-color: #88888888; border: 2px solid black; border-radius:5px; padding: 5px; user-select: none; }
		#tableTop { stroke: #CCCCCCFF; stroke-width: 2; vector-effect: non-scaling-stroke; pointer-events: none; filter: drop-shadow(25px 75px 5px rgb(0 0 0 / 0.5)); }
		
		.bucketCircle { stroke:#000000; stroke-width:4; vector-effect:non-scaling-stroke; fill-opacity:0;}
		.bucketFill { stroke-opacity:0; fill:#00FFFF; fill-opacity:0.5; pointer-events:none;}
		.bucketTease { stroke-opacity:0; fill:#FF0000FF; fill-opacity:1; pointer-events:none;}
		.bucketText { fill: #000; stroke: #FFF; stroke-width: 0.5px; pointer-events:none;}
		
		.coinCircle { stroke:#00FFFF; stroke-width:2; vector-effect:non-scaling-stroke;}
		.coinImage { pointer-events:none; }
		.coinValueText { fill: #000; pointer-events:none;}
	
	</style>

	<script src="/socket.io/socket.io.js"></script>
	<script src="/node_modules/jquery/dist/jquery.js"></script>
	<script src="/node_modules/jquery-ui/dist/jquery-ui.js"></script>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<script>
		const TIME_OPTIONS = { hour12: false, hour: '2-digit', minute: '2-digit', fractionalSecondDigits: 3 }
		const fundingScale = 0.02;

		let infoDialog, form;

		function echo(packet){
			const msgLI =document.createElement("li");
			msgLI.classList.add("msgLI");
			msgLI.innerHTML = "<span class='t'>" + new Date(packet.time).toLocaleTimeString([], TIME_OPTIONS) + "></span> " + packet.message;
			$("#messages").append(msgLI);
			
			//If we're already scrolled to the bottom, keep it scrolled to the bottom.  If not, don't scroll as the user may be reading
			//if($("#activity")[0].scrollHeight - $("#activity").scrollTop() - $("#activity").outerHeight() < 1){
				$("#activity").animate({ scrollTop: $("#activity").prop("scrollHeight")}, 500);
			//}
		}
		function redrawCampaign(){
			let currentTime = new Date().getTime();
			let duration = campaign.marketEndTime - campaign.marketStartTime;
			let timeDelta = (currentTime < campaign.marketStartTime) ? campaign.marketStartTime - currentTime : campaign.marketEndTime - currentTime;
			let maxTime = Math.max(Math.abs(currentTime - campaign.marketStartTime), Math.abs(currentTime - campaign.marketEndTime));
			let timePixelSpan = $("#timeline").width();
			
			const TENSE = (currentTime < campaign.marketStartTime ? "future" : (currentTime < campaign.marketEndTime ? "present" : "past"));
			
			
			$("#timelineBefore").animate({"width": (TENSE == "future" ? timeDelta*(timePixelSpan/maxTime) : 0) + "px" }, 100); //If the event in in the future, there is no before
			$("#timelineDuring").animate({"width": (TENSE == "present" ? timePixelSpan : duration*(timePixelSpan/maxTime)) + "px" }, 100); //If we're currently in the market, make it span the entire screen.  Otherwise, figure the percentage. 
			$("#timelineAfter").animate({"width": (TENSE == "past" ? -timeDelta*(timePixelSpan/maxTime) : 0) + "px" }, 100); //If the event was in the past, expand this out (timeDelta will be negative); otherwise it should be 0 width
			
			//Determine where to mark "now"
			$("#timelineNow").animate({"left": (TENSE == "future" ? 0 : (TENSE == "present" ? (duration-timeDelta)*(timePixelSpan/duration) : (timePixelSpan))) - $("#timelineNow").width()/2 + "px" }, 100); //Left wall if upcoming, right-wall if past, mid-way if during
			
			//Adjust our message to include tense
			let timeMessage = "Market " + (TENSE == "future" ? "opens in " : (TENSE == "present" ? "closes in " : "closed ")) + timeDiffMessage(timeDelta) + (TENSE == "past" ? " ago." : ".");;
			
			let fundingMessage = "<br/>";
			let unspentFunding = Math.round(Number(campaign.unspentFunding)*100)/100;
			let overallFunding = Math.round(Number(campaign.overallFunding)*100)/100;
			
			if (unspentFunding >= 0){
				fundingMessage += "It has $" + unspentFunding.toLocaleString() + " left to spend (" + Math.round(100*unspentFunding/overallFunding) + "%)";
				if (overallFunding > unspentFunding) fundingMessage += " out of $" + overallFunding.toLocaleString() + " overall";
				fundingMessage += "!";
			}
			
			$("#campaignMessage").html(timeMessage + fundingMessage);
			
			
			$('#timelineDuring').progressbar({value:true});
		}

		window.onload = (event) => {
			$("#campaignName").html(campaign.name);
			
			var socket = io({auth:{token: 'test'}});
			
			var messages = $("#messages");
			var input = $("#input")[0];
			
			input.focus();
			
			/*socket.on('campaign', function(packetString){
				let packet = JSON.parse(packetString);
				echo(packet);
				campaign = JSON.parse(packet.message);
				
				let value = Number(campaign.spentFunds)/Number(campaign.overallFunding)*100;
				if (Number.isFinite(value)) $("#timelineDuring").progressbar( "option", {value});
				
				redrawCampaign();
			});*/
			socket.on('coin', function(packetString){
				let packet = JSON.parse(packetString);
				echo(packet);
				coin = JSON.parse(packet.message).coin;
				
				$("#coinMessage").html('This part is under construction, but here\'s the raw values:<br />' + 	JSON.stringify(coin, "", "<br />"));
				
			});
			socket.on('coinValues', function(packetString){
				let packet = JSON.parse(packetString);
				let coinValues = JSON.parse(packet.message).coinValuesRange.data.values;
				echo(coinValues.join(","));
			});
			socket.on('all', function(packetString) {
				let packet = JSON.parse(packetString);
				echo(packet);
			});
			
			
			$("form").on('submit', function(e) {
				e.preventDefault();
				if (input.value) {
					socket.emit('chat', input.value);
					input.value = '';
				}
			});
			
			socket.emit('getCoin', coinID);
			
			infoDialog = $("#infoDialog").dialog({
				autoOpen: false,
				maxHeight: 800,
				minHeight: 300,
				width: "75%",
				minWidth: 400,
				
				//modal: true,
				buttons: {	},
				show: { effect: "fade",	duration: 1000 },
				hide: { effect: "fade",	duration: 1000 }
			});
			
			$('#infoButton').button().on('click', function() {
				infoDialog.dialog( infoDialog.dialog('isOpen') ? 'close' : 'open' );
			});	
			
			$('#activity').scrollTop($('#activity').prop('scrollHeight'));
			
			$('#timelineDuring').progressbar({value:false});

			setInterval(redrawCampaign, 1000);
			
			setTimeout(() => {
				SVG.transition().duration(5000).call(
					ZOOM.transform,
					d3.zoomIdentity.translate(SVG_WIDTH/2, SVG_HEIGHT/2).scale(25).translate(-(coinData[0].x), -(coinData[0].y))
			)}, 2000);
			
			const SVG_WIDTH = 1000;
			const SVG_HEIGHT = 1000;
			const TABLE_RADIUS = 250;
			const MIN_ZOOM = 0.50;
			const MAX_ZOOM = 50;
			
			//Create and set up our SVG (Scalable Vector Graphics - opting for this over Canvas due to data binding and interactivity performance)	
			const SVG = d3.select('#graph').append('svg')
				.style('position', 'absolute').style('top', '0').style('left', '0').style('width', '100%').style('height', '100%').style('display', 'block')
				.attr('viewBox', [0, 0, SVG_WIDTH, SVG_HEIGHT]);

			d3.dragDisable(window); //Prevents the entire window being bring dragged

			// create a tooltip used within the GUI
			let tooltip = d3.select('#graph').append('div').attr('id', 'tooltip');
			function refreshTooltip(event, subject){
				let currentTarget = event.currentTarget || event.sourceEvent.currentTarget;
				if (currentTarget){
					tooltip
						.style("left", event.x + 20 + "px")
						.style("top", event.y + 10 + "px")
					
					if(event.type == "mouseover"){
						tooltip.style('opacity', 1)
					}
					if(event.type == "mouseleave"){
						tooltip.style('opacity', 0)
						tooltip.html('')
						.style("left", 0 + "px")
						.style("top", 0 + "px")
					}

					if(currentTarget.classList){
						let currentTargetClass = currentTarget.classList[0];
						let currentTargetID = currentTarget.id;

						if(currentTargetClass == "bucketCircle"){
							tooltip.html(`Bucket "${subject.name}"<br>$${Math.round(subject.currentFunding)} of $${Math.round(subject.tier1Goal)} (tier 1)`)
						}
						else if(currentTargetClass == "coinCircle"){
							tooltip.html(`Coin #${currentTargetID.match(/\d+/g)[0]}'s value: $${Math.round(subject.value)}`)
						}
					}
								
				}else{
					tooltip.html('');
					console.log(`Tooltip cannot act upon ${currentTarget}.`);
				}
			}

			//Add some text to the GUI.
			let guiGroup = SVG.append("g").attr("id", "guiGroup");
			//guiGroup.append('text').attr('x', 5).attr('y', 160).style("fill", "white").text("For a good time, grab a few coins and put them in the buckets!");
			//guiGroup.append('text').attr('x', 5).attr('y', 180).style('fill', 'white').text("You can also pan & zoom like Google Maps!");

			//Set up our table top
			let tableGroup = SVG.append('g').attr('id', 'tableGroup');	
			let tableTop = tableGroup.append('svg:image')
				.attr('id', 'tableTop')
				.attr('xlink:href',  'https://spark-coin.com/public/TableTop.png')
				.attr('x', SVG_WIDTH/2 - TABLE_RADIUS)
				.attr('y', SVG_HEIGHT/2 - TABLE_RADIUS)
				.attr('width', TABLE_RADIUS*2)	
				.attr('height', TABLE_RADIUS*2)

			let bucketsGroup = tableGroup.append('g').attr('id', 'bucketsGroup')
				.style('filter', 'drop-shadow(25px 75px 5px rgb(0 0 0 / 0.5))');
				
			let coinsGroup = tableGroup.append('g').attr('id', 'coinsGroup').attr('cursor', 'grab')
				.style('filter', 'drop-shadow(2px 6px 1px rgb(0 0 0 / 0.5))');;
				
			//Set up simple pan & zoom for our tableGroup (responds to mouse actions on the entire SVG) 
			const ZOOM = d3.zoom()
				.scaleExtent([MIN_ZOOM, MAX_ZOOM])
				.on('zoom', e => tableGroup.attr('transform', e.transform))
			SVG.call(ZOOM);

			//Map our data for use in visualization
			let bucketData = campaign.buckets.map((e) => {return {name: e[0], currentFunding: e[1], tier1Goal: e[2], tier2Goal: e[3], tier3Goal: e[4], tease: 0, radius: Math.sqrt(e[2]*fundingScale)}	})
			bucketData = bucketData.filter((e) => {return e.name}); //Filter out those that don't have a name.
			
			let coinData = campaign.coins.map(function(e){	return {id: e.ID, value: e.currentValue, multiplier: e.multiplier, lastScanned: e.lastScanned, lastScannedBy: e.lastScannedBy, radius: Math.sqrt(e.currentValue*fundingScale)}	}); 
			const VALUE_PER_PIXEL = coinData.reduce((accumulator, currentCoin) => accumulator + currentCoin.value, 0)/(SVG_WIDTH*SVG_HEIGHT);
			console.log(`Value per pixel: ${VALUE_PER_PIXEL}`);
			
			//Set up our Buckets' force simulation
			let bucketSimulation = d3.forceSimulation(bucketData)
				.velocityDecay(0.08)
				.alphaDecay(0.003)
				//.force('centerB', d3.forceCenter(500, 300))
				.force('collideB', d3.forceCollide().radius((datum) => {
					return Math.sqrt(datum.tier1Goal*fundingScale) + 0.1;
				}).strength(1))
				.force('x', d3.forceX((datum, index) => {
					return (TABLE_RADIUS+datum.radius*2/*Math.sqrt(datum.tier1Goal*fundingScale)*/)*Math.cos(2*Math.PI/bucketData.length * index) + SVG_WIDTH/2;
				}).strength(0.01))
				.force('y', d3.forceY((datum, index) => {
					return (TABLE_RADIUS+datum.radius*2/*Math.sqrt(datum.tier1Goal*fundingScale)*/)*Math.sin(2*Math.PI/bucketData.length * index) + SVG_HEIGHT/2;
				}).strength(0.01))
				.on('tick', () => {
					bucketsGroup.selectAll('circle')
						.attr('cx', (datum, index, elements) => Math.round(datum.x*10)/10)
						.attr('cy', (datum, index, elements) => Math.round(datum.y*10)/10);
					bucketsGroup.selectAll('image')
						.attr('x', (datum, index, elements) => Math.round(datum.x*10)/10 - datum.radius)
						.attr('y', (datum, index, elements) => Math.round(datum.y*10)/10 - datum.radius)
					bucketsGroup.selectAll('text')
						.attr('x', (datum) => Math.round(datum.x))
						.attr('y', (datum) => Math.round(datum.y))
				});
			
			//Set up our coins' force simulation
			let coinSimulation = d3.forceSimulation(coinData)
				.velocityDecay(0.1)
				//.alphaDecay(0.1)
				.force('center',  d3.forceCenter(SVG_WIDTH/2, SVG_HEIGHT/2).strength(0.1))
				.force('x', d3.forceX((datum, index) => {
					return datum.forceX ? datum.forceX : SVG_WIDTH/2;
				}).strength((datum) => datum.forceX ? 0.5 : 0.001))
				.force('y', d3.forceY((datum, index) => {
					return datum.forceY ? datum.forceY : SVG_HEIGHT/2;
				}).strength((datum) => datum.forceX ? 0.5 : 0.001))
				//.force('charge', d3.forceManyBody().strength((datum, index) => (index != 0) ? 0: -10))
				.force('collide', d3.forceCollide().radius((datum, index) => {
					return Math.sqrt(datum.value*fundingScale) + 0.1
				}).strength(1))
				.on('tick', () => {
					coinsGroup.selectAll('circle')
						.attr('cx', (datum, index, elements) => Math.round(datum.x*10)/10)
						.attr('cy', (datum, index, elements) => Math.round(datum.y*10)/10);
					coinsGroup.selectAll('image')
						.attr('x', (datum, index, elements) => Math.round(datum.x*10)/10 - datum.radius)
						.attr('y', (datum, index, elements) => Math.round(datum.y*10)/10 - datum.radius)
					coinsGroup.selectAll('.coinValueText')
						.attr('x', (datum) => Math.round(datum.x*10)/10)
						.attr('y', (datum) => Math.round((datum.y + datum.radius*0.9)*10)/10)
					coinsGroup.selectAll('.coinIDText')
						.attr('x', (datum) => Math.round(datum.x*10)/10)
						.attr('y', (datum) => Math.round((datum.y - datum.radius*0.8)*10)/10)	
				});
			
			//This function is called on each new coin dot to enable their dragging behavior
			let dragBucketIndex = -1;
			let dragging = false;
			function drag(){
				
				return d3.drag()
					.on("start", (event, subject) => {
						event.sourceEvent.preventDefault();
						dragging = true;
						coinsGroup.attr("cursor", "grabbing");
						let draggedCircle = d3.select(event.sourceEvent.currentTarget).select('circle');
						draggedCircle
							.style('fill', '#FF0000')
							.style('fill-opacity', 0.5)
					})
					.on("drag", (event, subject) => {
						event.sourceEvent.preventDefault();
						
						//"Reheat" the simulations for interactive animation!
						coinSimulation.alpha(0.3).alphaTarget(0).restart();
						bucketSimulation.alpha(0.3).alphaTarget(0).restart();
						
						//Chase the cursor
						subject.forceX = event.x;							subject.forceY = event.y;
						coinSimulation.force('x').initialize(coinData);		coinSimulation.force('y').initialize(coinData);

						//See if we dragged over any buckets
						let newDraggedOverElements = d3.select(document.elementsFromPoint(event.sourceEvent.clientX || event.sourceEvent.touches[0].clientX, event.sourceEvent.clientY || event.sourceEvent.touches[0].clientY)).nodes()[0];
						let bucketElement = newDraggedOverElements.find((e) => {
							let id = e.getAttribute('id')
							if (id) return id.search(/bucketCircle/g) >= 0;
						});
						//If there is a bucketElement, grab the index from the id attribute using Regex; otherwise use -1 to signify no bucket
						let newDragBucketIndex = bucketElement ? bucketElement.getAttribute('id').match(/\d+/g)[0] : -1; 
						
						//See if our targets changed
						if (dragBucketIndex != newDragBucketIndex){ 
							if(dragBucketIndex >= 0) bucketData[dragBucketIndex].tease = 0; //We're no longer teasing the old bucket
							
							if(newDragBucketIndex >= 0){ //If we're over a bucket, snap to its center
								let goalGap = Math.max(bucketData[newDragBucketIndex].tier1Goal - bucketData[newDragBucketIndex].currentFunding, 0); //Don't be negative if the bucket is already overflowed.
								let fillAmount = Math.min(subject.value, goalGap); //Constrain our fill amount to avoid over-flowing.
								
								bucketData[newDragBucketIndex].tease += fillAmount;
								subject.fx = bucketElement.getAttribute('cx') - 0;//subject.radius;
								subject.fy = bucketElement.getAttribute('cy') - 0;//subject.radius;
							}else{	//Otherwise, make sure it's released.
								subject.fx = null;	subject.fy = null;	
							}		
							
							//console.log(`Drag target changed from ${dragBucketIndex >= 0 ? 'bucket' + dragBucketIndex : 'nothing'} to ${newDragBucketIndex >= 0 ? 'bucket' + newDragBucketIndex : 'nothing'}.`);
							dragBucketIndex = newDragBucketIndex;
							
							
						}
						refreshBuckets(); 
					})
					.on("end", (event, subject) => {
						dragging = false;
						event.sourceEvent.preventDefault();
						
						coinsGroup.attr("cursor", "grab"); //Change the cursor back

						//Check to see if we dragged onto anything (probably a bucket)
						if(dragBucketIndex >= 0){					
							bucketData[dragBucketIndex].tease = 0 //We're no longer teasing.
							
							//Calculate our fill amount.
							let goalGap = Math.max(bucketData[dragBucketIndex].tier1Goal - bucketData[dragBucketIndex].currentFunding, 0); //Don't be negative if the bucket is already overflowed.
							let fillAmount = Math.min(subject.value, goalGap); //Constrain our fill amount to avoid over-flowing.
							
							//If there is actually any value to transfer, let's execute the change
							if (fillAmount > 0){
							
								//The amount that's added to the bucket is deducted from the coin.
								bucketData[dragBucketIndex].currentFunding += fillAmount;
								subject.value -= fillAmount;
								subject.radius = Math.sqrt(subject.value*fundingScale);
																		
								//If there's nothing left on the coin, delete it.
								if (subject.value <= 0){
									//coinData.splice(subject.index, 1);
								}			
								
								//Our coins probably changed quite a bit, so re-initialize the forces
								coinSimulation.force('collide').initialize(coinData);
								coinSimulation.force('center').initialize(coinData); 
								
								console.log(`Coin #${subject.index} dropped onto ${dragBucketIndex} filling the remaining $${goalGap} with $${fillAmount} (now $${bucketData[dragBucketIndex].currentFunding}, ${Math.round(bucketData[dragBucketIndex].currentFunding/bucketData[dragBucketIndex].tier1Goal*100)}% full).`)
							}else console.log(`Coin #${subject.index} dropped onto ${dragBucketIndex}, but nothing was added.`);
											
						}else console.log(`Coin #${subject.index} dropped onto nothing.`)
					
						refreshCoins();
						refreshBuckets(); 
						
						//Stop chasing the cursor
						subject.forceX = null;
						subject.forceY = null;
						coinSimulation.force('x').initialize(coinData);
						coinSimulation.force('y').initialize(coinData);
						coinSimulation.alphaTarget(0).alpha(0.3).restart();
						//bucketSimulation.alphaTarget(0).alpha(0.3).restart();
					});
			}
			
			//(re)join the coin data to its elements
			function refreshCoins(){
				let coinDots = coinsGroup.selectAll('g').data(coinData, function(datum, index, temp){
					return datum.index;
				}).join(
					function(enteringCoins){ //New coins
						let coinGroups = enteringCoins.append('g');
						
						coinGroups.append('svg:image')
							.attr('id', (d,i) => 'coinImage' + i)						   
							.attr('class', 'coinImage')
							.attr('xlink:href',  'https://spark-coin.com/public/Heads.png')
							.attr('height', (datum) => datum.radius*2)//Math.sqrt(datum.value*fundingScale)*2)
							.attr('width', (datum) => datum.radius*2)//Math.sqrt(datum.value*fundingScale)*2);
							
						coinGroups.append('circle')
							.attr('id', (d,i) => 'coinCircle' + i)
							.attr('class', 'coinCircle')
							.on('mouseover',  (event, subject) => {if(dragging) return; event.currentTarget.style.stroke = '#FF0000FF'; refreshTooltip(event, subject);})
							.on('mousemove',  (event, subject) => {if(dragging) return; refreshTooltip(event, subject);})
							.on('mouseleave',  (event, subject) => {if(dragging) return; event.currentTarget.style.stroke = '#00FFFFFF'; refreshTooltip(event, subject);})
							.on("click", (event, subject) => event.currentTarget.style.opacity = 1)
							.attr('r', (datum) => datum.radius)//Math.sqrt(datum.value*fundingScale))
							.style('fill', '#00000000');
							
						coinGroups.append('text')
							.attr('class', 'coinValueText')
							.attr("text-anchor", "middle")
							.style('font-size', (datum) => datum.radius*0.2 + "px")
							.text((datum) => datum.value.toLocaleString(navigator.language, {style: "currency", currency: "USD"}))
							
						coinGroups.append('text')
							.attr('class', 'coinIDText')
							.attr("text-anchor", "middle")
							.style('font-size', (datum) => datum.radius*0.2 + "px")
							.text((datum) => "#" + datum.id)
							
						coinGroups.call(drag())
						
						console.log(enteringCoins.size() + " coins created.");
					},
					function(updatingCoins){
						updatingCoins.selectAll('image')
							.attr('height', (datum) => datum.radius*2)//Math.sqrt(datum.value*fundingScale)*2)
							.attr('width', (datum) => datum.radius*2)//Math.sqrt(datum.value*fundingScale)*2);		
							updatingCoins.selectAll('circle')
							.attr('r', (datum) => datum.radius)//Math.sqrt(datum.value*fundingScale))
							.style('fill', '#00000000');
						updatingCoins.selectAll('.coinValueText')
							.style('font-size', (datum) => datum.radius*0.2 + "px")
							.text((datum) => datum.value.toLocaleString(navigator.language, {style: "currency", currency: "USD"}))
							
						updatingCoins.selectAll('.coinIDText')
							.attr('class', 'coinIDText')
							.attr("text-anchor", "middle")
							.style('font-size', (datum) => datum.radius*0.2 + "px")
							.text((datum) => "#" + datum.id)
							
						console.log(updatingCoins.size() +  " coins updated.");
					},
					function(exitingCoins){
						exitingCoins.remove();
						console.log(exitingCoins.size() + " coins deleted.");
					});
							
				//d3.select('#coinCircle0')
					//.style('fill', '#00FF00CC');
			}refreshCoins();
			
			//(Re)join our bucket data to its elements
			function refreshBuckets(){
				let bucketDots = bucketsGroup.selectAll('g').data(bucketData, function(datum, index, temp){
					return datum.index;
				}).join(
					function(enteringBuckets){
						let bucketGroups = enteringBuckets.append('g');
						
						bucketGroups.append('svg:image')
							.attr('class', 'bucketImage')
							.attr('xlink:href',  'https://spark-coin.com/public/Bucket.png')
							.attr('height', (datum) => datum.radius*2)//Math.sqrt(datum.tier1Goal*fundingScale)*2) //Diameter is 2X the size of the circle radius later.
							.attr('width', (datum) => datum.radius*2)//Math.sqrt(datum.tier1Goal*fundingScale)*2)
						
						bucketGroups.append('circle')
							.attr('id', (d,i) => 'bucketCircle' + i)
							.attr('class', 'bucketCircle')
							.on('mouseover',  function (event, subject){
								if(dragging) return; 
								d3.select(event.currentTarget)
									.style('stroke', '#FF0000FF');
								refreshTooltip(event, subject);			
							})
							.on('mousemove',  function (event, subject){
								if(dragging) return; 
								refreshTooltip(event, subject)
							})
							.on('mouseleave',  function (event, subject){
								if(dragging) return; 
								d3.select(event.currentTarget)
									.style('stroke', '#000000FF');
								refreshTooltip(event, subject);
							})
							.transition()	
							.attr('r', (datum) => datum.radius)

						bucketGroups.append('circle')
							.attr('id', (d,i) => 'bucketFill' + i)
							.attr('class', 'bucketFill')			
							.transition()
							.style('fill-opacity', (datum) => (datum.currentFunding == datum.tier1Goal) ? 1 : 0.5)
							.attr('r', (datum) => Math.sqrt(datum.currentFunding*fundingScale))

						bucketGroups.append('circle')
							.attr('id', (d,i) => 'bucketTease' + i)
							.attr('class', 'bucketTease')
							.transition()
							.style('fill-opacity', (datum) => (datum.currentFunding + datum.tease >= datum.tier1Goal) ? 1 : 0.5)
							.attr('r', (datum) => Math.sqrt((datum.tease > 0 ? datum.currentFunding + datum.tease : 0)*fundingScale));
											
						bucketGroups.append('text')
							.attr('class', 'bucketText')
							.text((datum) => Math.round((datum.currentFunding/datum.tier1Goal)*100) + "%")
							
					},
					function(updatingBuckets){
						updatingBuckets.selectAll('.bucketFill')
							.transition()
							.style('fill-opacity', (datum) => (datum.currentFunding == datum.tier1Goal) ? 1 : 0.5)
							.attr('r', (datum) => Math.sqrt(datum.currentFunding*fundingScale))
							
						updatingBuckets.selectAll('.bucketTease')
							.transition()
							.style('fill-opacity', (datum) => (datum.currentFunding + datum.tease >= datum.tier1Goal) ? 1 : 0.5)
							.attr('r', (datum) => Math.sqrt((datum.tease > 0 ? datum.currentFunding + datum.tease : 0)*fundingScale));
							
						updatingBuckets.selectAll('text')
							.text((datum) => Math.round((datum.currentFunding/datum.tier1Goal)*100) + "%")
					},
					function(exitingBuckets){
						exitingBuckets.remove();
					});
			}refreshBuckets();
			
		}
	
		function timeDiffMessage(timeDelta){
			//Break down the difference in millisecond timestamps into days, hours, minutes, seconds.
			let chunk = Math.abs(timeDelta);
			const DAYS = Math.floor(chunk/86400000); chunk -= DAYS*86400000;
			const HOURS = Math.floor(chunk/3600000); chunk -= HOURS*3600000;
			const MINUTES = Math.floor(chunk/60000); chunk -= MINUTES*60000;
			const SECONDS = Math.round(chunk/1000);
			return (DAYS ? DAYS + `day${DAYS > 1? 's' : ''} ` : "") + (HOURS ? HOURS + `hr${HOURS > 1? 's' : ''} ` : "") + (MINUTES ? MINUTES + "min " : "") + SECONDS + "s";
		}
		

	</script>
</head>
<body>
	<h1 id="campaignName">Loading...</h1>
	<div id="timeline">
		<div id="timelineBefore"></div>
		<div id="timelineDuring"></div>
		<div id="timelineAfter"></div>
		<div id="timelineNow">Now</div>
	</div>
	<div id="campaignMessage"></div>
	<div id="coinMessage"></div>
	<div id="graph"></div>
	

	<div id="activity">
		<ul id="preamble">
			<%-preamble%>
		</ul>

		<ul id="messages"></ul>
		<form id="form" action="">
			<input id="input" placeholder="[USER] >" autocomplete="off" /><button>Send</button>
			<button id="infoButton" class="ui-button ui-widget ui-corner-all ui-button-icon-only" title="Info">
				<span class="ui-icon ui-icon-info"></span>Info
			</button>
		</form>
	</div>
</body>

<script>
	let campaign = {
		spreadsheetId: <%-campaignSpreadsheetID%>,
		spreadsheetURL: <%-campaignSpreadsheetURL%>,
		spreadsheetLayout: <%-campaignSpreadsheetLayout%>,
		sheetId: <%-campaignSheetId%>,
		name: <%-campaignName%>,
		info: <%-campaignInfo%>,
		coins: <%-campaignCoins%>,
		buckets: <%-campaignBuckets%>,
		marketStartTime: <%-campaignMarketStartTime%>,
		marketEndTime: <%-campaignMarketEndTime%>
	};
	
	let preamble = `<%-preamble%>`;
	let clientName = "<%-clientName%>";
	let coinCampaignID = "<%-coinCampaignID%>";
	let coinID = "<%-coinID%>";
	let coinSecret = "<%-coinSecret%>"; //If you're a client, you've found the secret code that's embedded in you coin!  Though, you could've just looked at the URL =P
	const SPREADSHEET_URL = <%-campaignSpreadsheetURL%>;
	const DEBUG = <%-clientDebug%>;
</script>